# Вопросы к экзамену

## Содержание
1. [Тестирование](#тестирование)   
2. [Отладка](#отладка)    <!---->
3. [Переменные и константы](#переменные-и-константы)       
4. [Сложные типы данных](#сложные-типы-данных)   
5. [Управляющие конструкции](#управляющие-конструкции)   
6. [Функции](#функции)
7. [Свойства объектов](#свойства-объектов)   
8. [Функции объектов](#функции-объектов)    
9. [Сравнение объектов](#сравнение-объектов)
10. [Копирование объектов](#копирование-объектов)    
11. [Понятие класса](#понятие-класса)    
12. [Первичный конструктор](#первичный-конструктор)   
13. [Вторичный конструктор](#вторичный-конструктор)   
14. [Свойства объекта-компаньона](#свойства-объекта-компаньона)   
15. [Функции объекта-компаньона](#функции-объекта-компаньона)    
16. [Синглтон и перечисления](#синглтон-и-перечисления)   
17. [Дата классы](#дата-классы)
18. [Композиция](#композиция)<!---->
19. [Наследование](#наследование)
20. [Реализация](#реализация)<!---->
21. [Параметризация](#параметризация)<!---->
22. [Абстрактные классы](#абстрактные-классы)
23. [Множественное наследование](#множественное-наследование)<!---->
24. [Полиморфизм](#полиморфизм)<!---->
25. [SOLID](#solid)<!---->
26. [Ковариантный параметр](#ковариантный-параметр)<!---->
27. [Контравариантынй параметр](#контравариантынй-параметр)<!---->
28. [Обработка ошибок с помощью null-типов](#обработка-ошибок-с-помощью-null-типов)
29. [Контроль ошибок с помощью кодов](#контроль-ошибок-с-помощью-кодов)
30. [Контроль ошибок с помощью исключений](#контроль-ошибок-с-помощью-исключений)<!---->
31. [Функциональная обработка ошибок](#функциональная-обработка-ошибок)<!---->
32. [Рефлексия в программировании](#рефлексия-в-программировании)<!---->
33. [Аннотации в программировании](#аннотации-в-программировании)<!---->
34. [Делегаты в Kotlin](#делегаты-в-kotlin)<!---->
35. [Внедрение зависимостей](#внедрение-зависимостей)<!---->
___

## Тестирование
Для начала подключаем библиотеку тестирования `kotest`. Ниже приведен блок кода конфигурации build.gradle.kts.
```Kotlin
val kotestVersion = "5.4.1"
dependencies{
    testImplementation(
        "io.kotest:kotest-runner-junit5-jvm:$kotestVersion") }
tasks.withType<Test>().configureEach {
    useJUnitPlatform() }
```
Тесты записываются в класссе, наследующим StringSpec. StringSpec сводит синтаксис к абсолютному минимуму. 
Просто напишите строку, за которой следует лямбда-выражение с вашим тестовым кодом. Should be дословно переводится как "должно быть". 
Оно сравнивает эксперементальный результат с теоритическим. На этом построены все тесты.
```Kotlin
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe
class GreatTest : StringSpec({
    "Простой тест" {
        great("Вася") shouldBe "Hello, Вася"
    }
})
```
▲ [Содержание](#содержание)
## Отладка
>>>> Ожидание дополнений...     

▲ [Содержание](#содержание)
## Переменные и константы
**Пременные**   
Переменные могут быть двух видов: `val` и `var`. 
`val` происходит от слова value - неизменная величена, а `var` от variable - изменяемая величена.   

Синтаксис (общий вид):
```Kotlin
var/val название_переменной : тип_переменной = значение
```
*Примеры использования:*
```Kotlin
val a: Int = 1    // Общий вид
val b = 2         // Тип `Int` выводится компилятором
val c: Int        // Без инициализации тип обязателен
c = 3             // Отложенная инициализация
var x = 5         // Тип `Int` выводится компилятором
x += 1            // var можно изменять
```

**Константы**  
Константы имеют ключевое слово `const`.     
Пример:
```Kotlin
const val SIZE : Int = 15
```
> **Отличие `val` от `const`**    
Значение переменной `val` инициализируется во время выполнения, а `const` - во время компиляции. 

**Типы данных**     
*Целочисленные:*  
Byte (8 бит), Short (16), Int (32), Long (64).
```Kotlin
val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1

val hex = 0x0F // 16-я cc
val bin = 0b00001011 // 2-я сс

val oneMillion = 1_000_000 // `_` для удобного чтения 
```
*Вещественные:*       
Float (32, IEEE754 single), Double (64, IEEE754 double).
```Kotlin
val pi = 3.14 // Double
// val one: Double = 1 // Error: type mismatch
val oneDouble = 1.0 // Double
val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float, фактическое значение равно 2.7182817

val scienceNotation = 123.5e10 
```
*Символьные:*       
Char (1 символ, поддерживает Unicode), String (Строка).     
```Kotlin
val aChar: Char = 'a'
println(aChar)
println('\n') // переход на другую строку
println('\uFF00') // ?

val s = "Hello, world!\n"
val text = """
    for (c in "foo")
        print(c)
"""
```
*Логические:*       
Boolean
```Kotlin
val myTrue: Boolean = true
val myFalse: Boolean = false
```
▲ [Содержание](#содержание)
## Сложные типы данных

*Приметивы и объекты*     
```Kotlin
val number: Int = 1
val numberString: String = number.toString()
```
- Объекты имеют больше возможностей.
- Примитивы требуют меньше ресурсов.
- Kotlin автоматически выбирает представление встроенных типов.

*Массивы*       
```Kotlin
val x: IntArray = intArrayOf(1, 2, 3)     // массив примитивов
val y: Array< Int > = arrayOf(1, 2, 3)    // массив объектов
// Первый аргумент Array - размер массива
// второй - функция инициализации (i - индекс элемента)
val z: Array< Int > = Array(5, { i -> i*i }) 

x[0] = у.size          // 3
x[1] = z.last()        // 16
```

*Коллекции*     
```Kotlin
val x = ArrayList<Int>()
x.addAll(listOf(1, 2, 3))
x.add(5)
print(x)
``` 
```
[1, 2, 3, 5]
```
*Структура данных*      
```Kotlin
class Good(val price: Float, val name: String)

val mail: Good = Good(10F, "mail")
val awl: Good = Good(20F, "awl")

val total = mail.price + awl.price
``` 

*Диапозоны*
```Kotlin
val r1: IntRange = 1..10
val r2: IntProgression = 10 downTo 1 step 2

println(5 in r1)
println(5 !in r2)
```
```
true
true
```

*Строки. Представления*     
```Kotlin
val i = 42
val s = "answer is $i"
val charArray: CharArray = s.toCharArray()
charArray[0] = charArray[0].uppercaseChar()
val newS: String = String(charArray)
print(newS)
```
```
Answer is 42
```

*Строки. Операции*      
```Kotlin
val s1 = "string one"
println(s1.uppercase())
println(s1.replace(" ", "_"))
println(s1.substring(1 .. 3))
println(s1.split(" "))
```
```
STRING ONE
string_one
tri
[string, one]
```

*Кортежи (tuples)*      
```Kotlin
val p: Pair<Int, String> = Pair(1,"")
val t: Triple<Int, String, Char> = 
        Triple(p.first, p.second, '1')
```
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Управляющие конструкции
**Ветвление**
```Kotlin
if (a % 2 == 0)
    print("a is even\n")
else
    print("a is odd\n")

val min = if (a < b) a else b
```
- Условие имеет тип Boolean.
- Возвращает значение.

**Выбор**
```Kotlin
var result = when(a){
    in 0..6 -> "ночь"
    in 6..12 -> "утро"
    in 12..18 -> "день"
    in 18..24 -> "вечер"
    else -> "ошибка"
}
```
Структурная конструкция (нет break!)

**Цикл для перебора**
```Kotlin
for(i in 0..5){
    print(i)
}
```
```Kotlin
val a = arrayOf(1, 2, 3)
var s = 0
for(x in a){
    s += x
}
```
Применяется при заранее известном числе повторений.

**Цикл для итераций**
```Kotlin
var bits = 10
while (bits > 0) {
    val tmp = bits / 2
    print(bits - 2 * tmp)
    bits = tmp
}
```
```Kotlin
print("\nEnter Yes\n")
do {
    val x = readLine()
} while (x != "Yes")
```

**Прерывание циклов**     
Kotlin содержит операторы continue(завершить шаг цикла) и break (завершить цикл), но при правильном подходе к реализации алгоритмов они не нужны.

>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Функции
**Объявление и вызов**      
```Kotlin
fun greeting(name: String): String {
    return "Hello $name"
}

print(greeting("Sheldon"))
```
**Аргументы по-умолчанию**
```Kotlin
fun greeting(name: String,
            prefix: String = "Dr."): String {
    return "Hello $prefix $name\n"
}

print(greeting("Sheldon"))
print(greeting("Howard", "Mr"))
```
**Именованные аргументы**
```Kotlin
fun greeting(name: String,
            prefix: String = "Dr.",
            greeting: String = "Hello"): String {
    return "Hello $prefix $name\n"
}

print(greeting("Sheldon", greeting = "Hi"))
```
**Функции из одного выражения**
```Kotlin
fun greeting(name: String,
            prefix: String = "Dr.",
            greeting: String = "Hello") =
    "Hello $prefix $name\n"
```
**Лямбда-функции**
```Kotlin
val arr: Array< Int > = Array(10) { it }

val isEven: (Int) -> Boolean = { n: Int -> n.rem(2) == 0 }

val evenArr: Array< Boolean > = Array(10, isEven)

val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y}
```

>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Свойства объектов

Свойство объекта - это переменная. В Kotlin для ее определения могут пременяться различные манипуляции.

**Геттеры и сеттеры**   
Геттеры (getter) и сеттеры (setter) (еще их называют методами доступа) позволяют управлять доступом к переменной.   
Геттер *определяет* значение переменной по прописанному методу, а сеттер *меняет* ее по прописанному методу.
Геттер:
```Kotlin
val x: Int
    get(value){ 
        if (value < 0)
            return -1
        return value
    }
``` 
Сеттер: 
```Kotlin
val y: Int = 0
    set(value){ 
        if (value % 2 == 0)
            field = value
        else 
            field = value - 1
    }
```
*field* - автоматически генерируемое поле, которое непосредственно хранит значение свойства.  
*value* - параметр, через который передается устанавливаемое значение.

**Nullable type**   
*Nullable* типы - это типы, переменный которых могут хранить два состояния: null (отсутствие состояние) и значение (само состояние).    
Пример:
```Kotlin
val x: Int? // может хранить значение `Int` или null
val y: Char // хранит только значение
```
// добавить определения !!, ?., ?! и тд

**Умное преобразование**    
В разных ЯП встречается преобразование типов. Например, из целого в вещественное и наоборот.    
Такое преобразование возможно, но имеет ограничения, например, переменные должны быть не null-евыми, в этом случае можно к каждому типу дописывать `?`, но это лишь снизит эффективность.
Пример: 
```Kotlin
val y: Int? = x
val a: Int = if (y != null) { // проверяет, что у не null-тип
    y*12
    } else {
    0
    }
```
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Функции объектов
**Создание функций**
Функции могут оформляться двумя видами:
```Kotlin
// `fun` - ключевое слово
fun название_функции (параметры){тело_функции}
fun тип_примимаемого_аргумента.название_функции (параметры){тело_функции} // в этом случае для обращения к принемаемому аргументу используется ключевое слово `this`
```
**Контекст**    
// добавить

>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Сравнение объектов

**Ссылка**  
```Kotlin
val x =         // Ссылка
    Array(3){it}// Функция -
                // конструктор
```

**Тип объекта** 
```Kotlin
val s = x.size      // Свойство
val l = x.last()    // Функция
```

**Сравнение объектов и ссылок**     
```Kotlin
val a = 1..5
val b = a.first.. a.last
val c = a
// Структурное равенство
println(a == b)      // true
println(a == c)      // true
// Реферативное (ссылочное) равенство
println(a === b)     // false
println(a === c)     // true
```

**Сравнение вложеных объектов** 
```Kotlin
val t1 = arrayOf(1,2)
val a = arrayOf(t1)
val b = arrayOf(t1)
println(a == b)         // false, warning!
println(a.contentEquals(b))     // true

val c = arrayOf(arrayOf(1,2))
println(a == c)         // false, warning!
println(a.contentEquals(c))     // false
println(a.contentDeepEquals(c)) // true
```
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Копирование объектов 

Примитив.   
Это – значение «примитивного» типа (string, int, char, boolen, float...).   
Объект.     
Может хранить множество значений как свойства.  


Примитив не имеет ссылок, ссылки только у объектов.
```Kotlin
fun main(){
    val a = 1 // примитив
    val b: Int? = readLine()?.toInt() // b = 1 // котлин видит как объект
    val c = a // c = 1 - тоже примитив
    var d: Int? = b // имеет одну и ту же ссылку // d = 1, b = 1
    d = 2 // сменил ссылку, все еще объект
}
```

Массив - полноценный объект.    
.clone() как будто создает новое имя, ссылки на объекты те же.
```Kotlin
fun main(){
    val x = Array(2){it} // массив имеет ссылку на себя (на массив) и на его элементы
    val y = x            // имеет одинаковые ссылки на все элементы, при изменении х у тоже поменяется
    val z = x.clone()    // на элементы ссылки совпадают, на массив - нет
    x[0] = 1             // у поменяется, z - нет
}
```

<!-- >>>> Ожидание дополнений... -->

▲ [Содержание](#содержание)
## Понятие класса    

Класс - это "набор" свойств и методов определенной группы.  Ключевое слово `class`.
Например, класс "Человек" имеет сдующие характеристики: пол, возраст, рост... Это описание класса. А объект этого класса будет "конкретный" человек, имеющий определенный пол, возраст, рост...
 ```Kotlin
class Person(val name: String){ // принимает аргумент
    var age: Int = 18 // свойства могут быть определены по-умолчанию
}
fun main(){
    val Alex: Person = Person("Alex") // создание объекта с использованием агрумента
    Alex.age = 20 // изменение свойства
}
```
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Первичный конструктор

Первичный конструктор - параметры конструктора, записанные в скобках.
```Kotlin
class NameClass (конструктор) {...}
```
Параметры могут быть разных видов:
```Kotlin
class Person (val name: String, var age: Int = 16, t: Int){...}
```
Первый пораметр задается при инициализации и принимается в качестве аргумента.  
Второй изначально имеет значение и его можно не инициализировать.   
Третий не имеет ключевого слова `val` или `var`. Они являюстя параметрами, но не свойствами конструктора. Невозможно работать с ними вне конструктора.   
// проверить!!
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Вторичный конструктор 
Вторичный конструктор находится в теле класса с ключевым словом `constructor`. Параметры могут быть отличными от первычного, но класс должен вернуть пареметры именно первичного конструктора (ключевое слово `this`).      
Пример:
```Kotlin
class Person (val firstname: String, val surname: String){
    constructor(fullName: String): this(
        fullName.split(" ")[0],
        fullName.split(" ")[1]
    )
    ...
}
```

**Блок инициализации**  
Основной конструктор не может в себе содержать какую-либо логику по инициализации свойств (исполняемый код). Он предназначен исключительно для объявления свойств и присвоения им полученных значений. Поэтому вся логика может быть помещена в блок инициализации - блок кода, обязательно выполняемый *при создании объекта* независимо от того, с помощью какого конструктора этот объект создаётся. Помечается он словом `init`.

```Kotlin
class Person(_name: String){
    val name: String
    init{
        name = _name
    }
    ...
}
```

По сути блок иницилизации - это способ настроить переменные или значения, а также проверить, что были переданы допустимые параметры. Код в блоке инициализации выполняется сразу после создания экземпляра класса, т.е. сразу после вызова основного конструктора.

▲ [Содержание](#содержание)
## Свойства объекта-компаньона

Объект-компаньон является состовляющей класса и хранит в себе статические свойства и методы/функции. Cтатические свойства и методы/функции не меняются и соществуют "всегда", как до создания объетка, так и после. К ним можно обратиться в конструкторе при инициализации.        
Ключевое слово `companion`.
```Kotlin
class Board(){
    companion object{
        val size = 5
    }
    ...
}
```
<!-- >>>> Ожидание дополнений... -->

▲ [Содержание](#содержание)
## Функции объекта-компаньона
См. Свойства объекта-компаньона

Пример:
```Kotlin
class Board(){
    companion object{
        val size = 5
        fun sum(val a: Int, val b: Int): Int{
            return a + b
        }
    }
    ...
}
```

▲ [Содержание](#содержание)
## Синглтон и перечисления

**Синглтон**    
Класс синглтон (Singleton) - это класс, который определяется таким образом, что только один экземпляр класса может быть создан и использован везде.
По сути, это объект, имеющий свойства и методы, который не имеет себе подобных объектов, т.е. объектов с тем же набором свойств и методов.  
Пример: 
```Kotlin
object Univer{
    val name: String = "Университет"
}

fun main() {
    println(Univer.name)
}
```

**Перечисления**    
Enums или перечисления представляют тип данных, который позволяет определить набор логически связанных констант. Для определения перечисления применяются ключевые слова `enum class`.

```Kotlin
enum class Day{
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```
Классы перечислений как и обычные классы также могут иметь конструктор. Кроме того, для констант перечисления также может вызываться конструктор для их инициализации.
```Kotlin
enum class Day(val value: Int){
    MONDAY(1), TUESDAY(2), WEDNESDAY(3),
    THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(100500)
}
 
fun main() {
 
    val day: Day = Day.FRIDAY
    println(day.value)        // 5
    println(Day.MONDAY.value) // 1
}
```
Встроенные свойства и вспомогательные методы:   
- `name`: возвращает название константы в виде строки
- `ordinal`: возвращает порядковый номер константы

Также в объектах могут быть пере-/определены свойства и функции.    
```Kotlin
enum class DayTime{
    DAY{
        override val startHour = 6
        override val endHour = 21
        override fun printName(){
            println("День")
        }
    },
    ...
}
```
<!-- >>>> Ожидание дополнений... -->

<!-- ```Kotlin
```  -->
▲ [Содержание](#содержание)
## Дата классы

Иногда классы бывают необходимы только для хранения некоторых данных. В Kotlin такие классы называются data-классы. Они определяются с модификатором `data`:
```Kotlin
data class Person(val name: String, val age: Int)
```

При компиляции такого класса компилятор автоматически добавляет в класс функции с определенной реализацией, которая учитывает свойства класса, которые определены в первичном конструкторе:

- equals(): сравнивает два объекта на равенство
- hashCode(): возвращает хеш-код объекта
- toString(): возвращает строковое представление объекта
- copy(): копирует данные объекта в другой объект
Например, возьмем функцию toString(), которая возвращает строковое представление объекта:   
```Kotlin
fun main() {
 
    val alice: Person = Person("Alice", 24)
    println(alice.toString())
}
 
class Person(val name: String, val age: Int)

// Результат:
// Person@2a18f23c
```
По умолчанию строковое представление объекта нам практически ни о чем не говорит. Как правило, данная функция предназначена для вывода состояния объекта, но для этого ее надо переопределять. Однако теперь добавим модификатор data к определению класса: 
```Kotlin
data class Person(val name: String, val age: Int)

// Результат:
// Person(name=Alice, age=24)
```

То есть мы можем увидить, какие данные хранятся в объекте, какие они имеют значения. То же самое касается всех остальных функций. Таким образом, в случае с data-классами мы имеем готовую реализацию для этих функций. Их не надо вручную переопределять. Но вполне возможно нас может не устраивать эта реализация, тогда мы можем определить свою:
```Kotlin
data class Person(val name: String, val age: Int){
    override fun toString(): String {
        return "Name: $name  Age: $age"
    }
}
```

При этом чтобы класс определить как data-класс, он должен соответствовать ряду условий: 
- Первичный конструктор должен иметь как минимум один параметр
- Все параметры первичного конструктора должны предваряться ключевыми словами val или var, то есть определять свойства
- Свойства, которые определяются вне первичного конструктора, не используются в функциях toString, equals и hashCode
- Класс не должен определяться с модификаторами open, abstract, sealed или inner.

<!-- >>>> Ожидание дополнений... -->

▲ [Содержание](#содержание)
## Композиция
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Наследование

**Наследование** позволяет создавать классы, которые расширяют функциональность или изменяют поведение уже существующих классов. В отношении наследования выделяются два ключевых компонента. Прежде всего это **базовый класс** (класс-родитель, родительский класс, суперкласс), который определяет базовую функциональность. И **производный класс** (класс-наследник, подкласс), который наследует функциональность базового класса и может расширять или модифицировать ее.      

Чтобы функциональность класса можно было унаследовать, необходимо определить для этого класса аннотацию `open`. По-умолчанию без этой аннотации класс не может быть унаследован.      
Общий вид:    
```Kotlin
open class класс_родитель
class класс_наследник: класс_родитель
```

Например: создадим объект класса "работник", который наследует класс "человек". Данный объект будет иметь не только свойства и методы для работника, но и для человека.
```Kotlin
fun main() {
    val bob: Employee = Employee()
    bob.name = "Bob"
    bob.printName() // вызов функции класса_родителя
}
open class Person{
    var name: String = "Undefined"
    fun printName(){
        println(name)
    }
}
class Employee: Person()
```
> Замечание: если классу нужно передавать аргументы, то при наследовании их необходимо передать!        
> Пример:
```Kotlin
open class Person(val name: String){
    fun printName(){
        println(name)
    }
}
class Employee(empName: String): Person(empName)
```
Объект класса Программист может пользоваться свойствами/методами класса Работник и Человек, так как Программисту присущи качества и Работника и Человека.     
       
Свойство/метод из класса_родителя можно переопределить с помощью ключевого слова `override`. Например:
```Kotlin
fun main() {
    val anna: Employee = Employee("Анна")
    print(anna.fulname) // Самый лучший работник: Анна
}
open class Person{
    var name: String = "ИМЯ"
    var fulname: String = "ПОЛНОЕ ИМЯ"
}
class Employee(var name: String): Person(){
    override var fulname: String = "Самый лучший работник: " + name
}
```
<!-- >>>> Ожидание дополнений... -->

▲ [Содержание](#содержание)
## Реализация
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Параметризация
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Абстрактные классы

***Абстрактные классы*** - это классы, определенные с модификатором **abstract**.       
***Абстрактный класс*** - это класс, представляющий из себя “заготовку” для целого семейства классов, который описывает для них общий шаблон поведения. Отличительной особенностью абстрактных классов является то, что мы **не** можем создать объект подобного класса.

Он представляет собой характеристики, которые относятся к отпередленной группе, но не имеют четкой формы. Например, квадрат и круг - это фигуры, но фигуры так таковой не существует, у них из общего есть периметр и площадь, которые являются абстрактными. То есть периметр и площадь имеют все фигуры вне зависимости какой они формы.
```Kotlin
// абстрактный класс фигуры
abstract class Figure {
    // абстрактный метод для получения периметра
    abstract fun perimeter(): Float
 
    // абстрактный метод для получения площади
    abstract fun area(): Float
}
// производный класс прямоугольника
class Rectangle(val width: Float, val height: Float) : Figure()
{
    // переопределение получения периметра
    override fun perimeter(): Float{
        return width * 2 + height * 2
    }
    // переопрелеление получения площади
    override fun area(): Float{
        return width * height
    }
}
```
Или, например, **абсолютно все** транспортные средства, будь то автобус, самолет или лодка, они все могут перемещаться. Это будет абстрактным методом, так как это свойственно всей группе вне зависимости от их типа.
```Kotlin
// абстрактный класс транспорта
abstract class Transport {
    // абстрактные методы перемещения
    abstract fun move() // движение
    abstract fun stop() // остановка
}
// производный класс транспорта
class Car() : Transport()
{
    // переопределение для движения
    override fun move(){
        print("Ехать!\n")
    }
    // переопрелеление для остановки
    override fun stop(){
        print("Тормозить!\n")
    }
}
```
Абстрактные классы могут иметь конструктор, а так же они могут использоваться для наследования.
<!-- >>>> Ожидание дополнений... -->

▲ [Содержание](#содержание)
## Множественное наследование
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Полиморфизм
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## SOLID

- Single responsibility – единственная ответственность класса, инкапсуляция ресурсов.
- Open-closed – классы открыты для расширения, закрыты для модификации.
- Liskov substitution (подстановка Liskov) – вместо базовых типов можно подставлять наследников.
- Interface segregation – много специализированных интерфейсов лучше одного универсального.
- Dependency inversion – использовать зависимость на абстракциях.

>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Ковариантный параметр
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Контравариантынй параметр
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Обработка ошибок с помощью null-типов

Null-типы один из подходов обрботки ошибок, который характерен именно для Kotlin.   
Не инициализируется ссылками указатель - одна из частых ошибок.

**Ошибки внутри функции**   
В случае некорректных данных, можно возвращить null, иначе, если все хорошо, вернет значение определенного типа.
```Kotlin
fun String.parseNull(): Pair<Int, Int>? {
    val arr = split(" ")
    if (arr.size != 2)
        return null
    else {
        val x = arr[0].toIntOrNull() ?: return null
        val y = arr[1].toIntOrNull() ?: return null
        return Pair(x, y)
    }
}
```

**Обработка ошибок**
```Kotlin
fun stringParseNull(input: String): String {
    val result: Pair<Int, Int> =
        input.parseNull() // если не выполнилось, вернет "Error"
            ?: return "Error"
    return "$result"
}
```

**Обработка ошибок нескольких функций**
```Kotlin
fun Pair<Int, Int>.getShapeNull(): Char? {
    if (first !in 0..2) return null
    if (second !in 0..2) return null
    return board[first][second]
}

fun validateNull(input: String): Boolean? =
    input.parseNull()?.getShapeNull()?.let { it == ' ' } // можно последовательно вызывать несколько функций

fun stringValidateNull(input: String) =
    validateNull(input)?.toString()?:"Error" 
```
<!-- >>>> Ожидание дополнений... -->

▲ [Содержание](#содержание)
## Контроль ошибок с помощью кодов

Если в функции произошла ошибка, то она возвращает код ошибки -> проверяет: это результат или ошибка? -> итог.  
**Ошибки внутри функции**   
Можно самим закодировать ошибки, создав константы, и вощать их в некоторых случаях. Таким образом, функции не содержат null-типов.  
```Kotlin
class ParseErrorCode {
    companion object {
        val NUMBER = Pair(-1, 0)
        val TYPE = Pair(-2, 0)
    }
}
fun String.parseCode(): Pair<Int, Int> {
    val arr = split(" ")
    if (arr.size != 2)
        return ParseErrorCode.NUMBER
    else {
        val x = arr[0].toIntOrNull() ?: return ParseErrorCode.TYPE
        val y = arr[1].toIntOrNull() ?: return ParseErrorCode.TYPE
        return Pair(x, y)
    }
}
```
**Обработка ошибок**    
В этом случае должна быть явная проверка на наличие ошибок. Есть сложность поддержки такого кода (при его изменении).   
```Kotlin
fun stringParseCode(input: String): String {
    val result = input.parseCode()
    return when (result) {
        ParseErrorCode.NUMBER -> ErrorMessage.NUMBER
        ParseErrorCode.TYPE -> ErrorMessage.TYPE
        else -> {
            "$result"
        }
    }
}
```
```Kotlin
class GetErrorCode {
    companion object {
        const val OUT = '!' 
    }
}

fun Pair<Int, Int>.getShapeCode(): Char {
    if (first !in 0..2) return GetErrorCode.OUT
    if (second !in 0..2) return GetErrorCode.OUT
    return board[first][second]
}
```
**Обработка ошибок нескольких функций** 
Требуется гораздо больше логики, чтобы проанализировать все коды ошибок.    
+: имеется информация о "поломке".

```Kotlin
fun validateCode(input: String): Pair<Boolean, String> {
    val point = input.parseCode()
    if (point == ParseErrorCode.TYPE) 
        return Pair(false, ErrorMessage.TYPE)
    if (point == ParseErrorCode.NUMBER) 
        return Pair(false, ErrorMessage.NUMBER)
    val char = point.getShapeCode()
    if(char == GetErrorCode.OUT) 
        return Pair(false, ErrorMessage.OUT)
    return Pair(char == ' ', ErrorMessage.OK)
}
fun stringValidateCode(input: String): String {
    val validate = validateCode(input)
    return if (validate.second ==ErrorMessage.OK)
        validate.first.toString()
    else
        validate.second
}
```
<!-- >>>> Ожидание дополнений... -->

▲ [Содержание](#содержание)
## Контроль ошибок с помощью исключений
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Функциональная обработка ошибок
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Рефлексия в программировании
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Аннотации в программировании
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Делегаты в Kotlin
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Внедрение зависимостей
>>>> Ожидание дополнений...

▲ [Содержание](#содержание)
## Вывод
>>>> Пока нет...
